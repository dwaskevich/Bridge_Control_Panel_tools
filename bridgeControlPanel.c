/*
 * bridgeControlPanel.c
 *
 *  Created on: Mar 6, 2022
 *      Author: Waskevich
 *
 *  Usage:
 *  	- Include header in main.c (#include "bridgeControlPanel.h")
 *  	- Define contents of register map in bridgeControlPanel.h
 *  		- Always include "uint16  CycleCount" since it's used in check_BCP()
 *  			- If unwanted, remove the arbitrary transaction counter in check_BCP()
 *  	- To use/read/write Register Map contents in the main application, include
 *  	  a declaration (extern bcp_stc_RegisterMap_t RegisterMap;) in main.c
 *
 */

#include "cy_pdl.h"
#include "cycfg.h"
#include "bridgeControlPanel.h"

bcp_stc_RegisterMap_t RegisterMap;
extern cy_stc_scb_ezi2c_context_t ezi2c_context;

/*******************************************************************************
* Function Name: initialize_bcp
********************************************************************************
* Summary:
* - initialize EZI2C peripheral and set secondary buffer to communicate with
*   the Bridge Control Panel tool.
*
*******************************************************************************/
void initialize_BCP(void)
{
	cy_en_scb_ezi2c_status_t status = CY_SCB_EZI2C_SUCCESS;
	cy_stc_scb_ezi2c_config_t bcp_config;

	/* make a copy of the config structure generated by the Device Configurator */
	bcp_config = CYBSP_EZI2C_config;

	/* disable and deinit EZI2C peripheral */
	Cy_SCB_EZI2C_Disable(CYBSP_EZI2C_HW, &ezi2c_context);
	Cy_SCB_EZI2C_DeInit(CYBSP_EZI2C_HW);

	/* modify EZI2C configuration to include secondary address */
	bcp_config.numberOfAddresses = EZI2C_BCP_TWO_ADDRESSES;
	bcp_config.slaveAddress2 = EZI2C_BCP_SECONDARY_ADDRESS;

	/* re-initialize EZI2C peripheral with new/modified configuration */
	status = Cy_SCB_EZI2C_Init(CYBSP_EZI2C_HW, &bcp_config, &ezi2c_context);
	/* enable the block */
	Cy_SCB_EZI2C_Enable(CYBSP_EZI2C_HW);

	/* Set the CapSense data structure as the I2C buffer to be exposed to the
	 * master on primary slave address interface. Any I2C host tools such as
	 * the Tuner or the Bridge Control Panel can read this buffer but you can
	 * connect only one tool at a time.
	 */
	Cy_SCB_EZI2C_SetBuffer1(CYBSP_EZI2C_HW, (uint8 *)&cy_capsense_tuner,
							sizeof(cy_capsense_tuner), sizeof(cy_capsense_tuner),
							&ezi2c_context);

    /* Set the RegisterMap data structure as the I2C buffer to be exposed to the
     * master on secondary slave address interface. Any I2C host tools such as
     * the Tuner or the Bridge Control Panel can read this buffer but you can
     * connect only one tool at a time.
     */
    Cy_SCB_EZI2C_SetBuffer2(CYBSP_EZI2C_HW, (uint8 *)&RegisterMap,
                            sizeof(RegisterMap), sizeof(RegisterMap), &ezi2c_context);

}

/*******************************************************************************
* Function Name: check_BCP
********************************************************************************
* Summary:
* - Checks to see if a Master read transaction to the secondary slave address
*   has happened.
*
*******************************************************************************/
uint32_t check_BCP(void)
{
	uint32_t status; /* EZI2C function call status return value */

	/* I2C - BCP interface - read status of secondary address and do something if Master read transaction happened */
	status = Cy_SCB_EZI2C_GetActivity(CYBSP_EZI2C_HW, &ezi2c_context); /* Get slave status to see if a Master read transaction happened. */
	status &= CY_SCB_EZI2C_STATUS_READ2; /* mask status with read of secondary slave address */
	if(CY_SCB_EZI2C_STATUS_READ2 == status)
	{
		RegisterMap.CycleCount += 1; /* arbitrary transaction counter */
	}

	return status;
}

